The heuristic is based on Simulated Annealing (SA), where an initial solution is iteratively improved by making small changes to the job-machine assignments and evaluating their effect on the makespan, operation time, and machine load.

```python
import random
def heuristic(input_data):
    schedule = {}
    machine_available_time = {m: 0 for m in range(input_data['n_machines'] + 1)}
    job_latest_time = {j: 0 for j in input_data['jobs'].keys()}

    for job_id, operations in input_data['jobs'].items():
        schedule[job_id] = []

        for op_id, (machines, times) in enumerate(operations, start=1):
            # Seleccionar la máquina con menor tiempo disponible respetando tiempos de trabajo
            best_index = min(range(len(machines)), key=lambda i: max(machine_available_time[machines[i]], job_latest_time[job_id]))
            assigned_machine = machines[best_index]
            processing_time = times[best_index]
            start_time = max(machine_available_time[assigned_machine], job_latest_time[job_id])
            end_time = start_time + processing_time

            # Guardar la asignación
            schedule[job_id].append({
                'Operation': op_id,
                'Assigned Machine': assigned_machine + 1,
                'Start Time': start_time,
                'End Time': end_time,
                'Processing Time': processing_time
            })

            # Actualizar disponibilidad de la máquina y del trabajo
            machine_available_time[assigned_machine] = end_time
            job_latest_time[job_id] = end_time


    return schedule

```