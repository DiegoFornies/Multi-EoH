The heuristic is based on Simulated Annealing (SA), where an initial solution is iteratively improved by making small changes to the job-machine assignments and evaluating their effect on the makespan, operation time, and machine load.

Python Implementation:

```python
import random
import math

def heuristic(n_jobs, n_machines, jobs, initial_temperature=1000, cooling_rate=0.995, max_iterations=10000):
    def calculate_makespan(solution):
        machine_times = {i: 0 for i in range(1, n_machines + 1)}
        for job in solution.values():
            for op in job:
                machine_times[op['Assigned Machine']] = max(machine_times[op['Assigned Machine']], op['End Time'])
        return max(machine_times.values())
    
    def create_initial_solution():
        solution = {}
        for job_id, operations in jobs.items():
            job_schedule = []
            current_time = {i: 0 for i in range(1, n_machines + 1)}
            for op_idx, (machines, times) in enumerate(operations):
                min_start_time = min([current_time[m] for m in machines])
                for m, time in zip(machines, times):
                    start_time = max(min_start_time, current_time[m])
                    end_time = start_time + time
                    job_schedule.append({
                        'Operation': op_idx + 1,
                        'Assigned Machine': m,
                        'Start Time': start_time,
                        'End Time': end_time,
                        'Processing Time': time
                    })
                    current_time[m] = end_time
            solution[job_id] = job_schedule
        return solution
    
    def generate_neighbour(solution):
        neighbour = solution.copy()
        job_id = random.choice(list(neighbour.keys()))
        operation_idx = random.choice(range(len(neighbour[job_id])))
        operation = neighbour[job_id][operation_idx]
        
        # Randomly swap machine assignments for the operation
        new_machine = random.choice([m for m in range(1, n_machines + 1) if m != operation['Assigned Machine']])
        new_start_time = max([operation['Start Time'], neighbour[job_id][operation_idx]['Start Time']])
        new_end_time = new_start_time + operation['Processing Time']
        
        operation['Assigned Machine'] = new_machine
        operation['Start Time'] = new_start_time
        operation['End Time'] = new_end_time
        return neighbour
    
    def accept_move(current_makespan, neighbour_makespan, temperature):
        if neighbour_makespan < current_makespan:
            return True
        else:
            probability = math.exp((current_makespan - neighbour_makespan) / temperature)
            return random.random() < probability
    
    solution = create_initial_solution()
    current_makespan = calculate_makespan(solution)
    best_solution = solution
    best_makespan = current_makespan
    temperature = initial_temperature
    
    for iteration in range(max_iterations):
        neighbour = generate_neighbour(solution)
        neighbour_makespan = calculate_makespan(neighbour)
        
        if accept_move(current_makespan, neighbour_makespan, temperature):
            solution = neighbour
            current_makespan = neighbour_makespan
        
        if current_makespan < best_makespan:
            best_solution = solution
            best_makespan = current_makespan
        
        temperature *= cooling_rate
    
    return best_solution

```