This heuristic assigns jobs to machines by selecting the machine with the earliest available time, considering both machine and job constraints. It schedules operations sequentially, updates machine availability and job completion times, and returns a schedule with start and end times, ensuring efficient resource utilization for minimizing makespan.
```python
import random
def heuristic(input_data):
    schedule = {}
    machine_available_time = {m: 0 for m in range(input_data['n_machines'])}
    job_latest_time = {j: 0 for j in input_data['jobs'].keys()}

    for job_id, operations in input_data['jobs'].items():
        schedule[job_id] = []

        for op_id, (machines, times) in enumerate(operations, start=1):
            # Seleccionar la máquina con menor tiempo disponible respetando tiempos de trabajo
            best_index = min(range(len(machines)), key=lambda i: max(machine_available_time[machines[i]], job_latest_time[job_id]))
            assigned_machine = machines[best_index]
            processing_time = times[best_index]
            start_time = max(machine_available_time[assigned_machine], job_latest_time[job_id])
            end_time = start_time + processing_time

            # Guardar la asignación
            schedule[job_id].append({
                'Operation': op_id,
                'Assigned Machine': assigned_machine,
                'Start Time': start_time,
                'End Time': end_time,
                'Processing Time': processing_time
            })

            # Actualizar disponibilidad de la máquina y del trabajo
            machine_available_time[assigned_machine] = end_time
            job_latest_time[job_id] = end_time


    return schedule

```