
def heuristic(input_data):
    """
    A heuristic algorithm for solving the Flexible Job Shop Scheduling Problem (FJSP).

    This heuristic prioritizes jobs with the fewest operations and assigns operations to machines
    based on the earliest available time, considering both machine availability and job precedence.

    Args:
        input_data (dict): A dictionary containing the problem instance data, including:
            - n_jobs (int): The number of jobs.
            - n_machines (int): The number of machines.
            - jobs (dict): A dictionary representing the jobs, where keys are job IDs and
              values are lists of operations. Each operation is a tuple containing a list of
              possible machines and a list of corresponding processing times.

    Returns:
        dict: A dictionary representing the schedule, where keys are job IDs and values are
              lists of dictionaries. Each dictionary in the list represents an operation and
              contains the assigned machine, start time, end time, and processing time.
    """

    n_jobs = input_data['n_jobs']
    n_machines = input_data['n_machines']
    jobs_data = input_data['jobs']

    # Sort jobs by the number of operations (shortest job first)
    job_ids = sorted(jobs_data.keys(), key=lambda job_id: len(jobs_data[job_id]))

    # Initialize schedule and machine availability
    schedule = {}
    machine_available_time = {m: 0 for m in range(n_machines)}
    job_completion_time = {job_id: 0 for job_id in jobs_data.keys()}  # Track when a job can start its next op

    for job_id in job_ids:
        schedule[job_id] = []
        operations = jobs_data[job_id]
        current_job_completion_time = 0

        for op_idx, operation in enumerate(operations):
            possible_machines = operation[0]
            processing_times = operation[1]

            # Find the machine that allows the earliest completion time for this operation
            best_machine = None
            earliest_completion_time = float('inf')
            chosen_processing_time = None

            for m_idx, machine_id in enumerate(possible_machines):
                processing_time = processing_times[m_idx]
                start_time = max(machine_available_time[machine_id], current_job_completion_time)
                completion_time = start_time + processing_time

                if completion_time < earliest_completion_time:
                    earliest_completion_time = completion_time
                    best_machine = machine_id
                    chosen_processing_time = processing_time

            # Assign the operation to the best machine
            start_time = max(machine_available_time[best_machine], current_job_completion_time)
            end_time = start_time + chosen_processing_time

            schedule[job_id].append({
                'Operation': op_idx + 1,
                'Assigned Machine': best_machine,
                'Start Time': start_time,
                'End Time': end_time,
                'Processing Time': chosen_processing_time
            })

            # Update machine availability and job completion time
            machine_available_time[best_machine] = end_time
            current_job_completion_time = end_time

    return schedule
