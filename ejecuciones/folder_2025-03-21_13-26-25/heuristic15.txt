
def heuristic(input_data):
    """
    A heuristic for the Flexible Job Shop Scheduling Problem (FJSSP).

    This heuristic prioritizes operations based on the shortest processing time
    among available machines and attempts to balance machine load. It considers
    both operation feasibility (machine capabilities), machine feasibility
    (one operation at a time), and sequence feasibility (job order).

    Args:
        input_data (dict): A dictionary containing the problem instance data,
                           including the number of jobs, machines, and
                           operation details (machines, processing times).

    Returns:
        dict: A dictionary representing the schedule, with job numbers as keys and
              lists of operation dictionaries as values. Each operation
              dictionary contains information about the assigned machine,
              start time, end time, and processing time.
    """

    n_jobs = input_data['n_jobs']
    n_machines = input_data['n_machines']
    jobs_data = input_data['jobs']

    schedule = {}
    machine_available_time = {m: 0 for m in range(n_machines)}
    job_completion_time = {j: 0 for j in range(1, n_jobs + 1)}
    
    remaining_operations = {j: list(range(1, len(jobs_data[j]) + 1)) for j in jobs_data}  # Track operations

    while any(remaining_operations.values()):  # While there are operations left

        eligible_operations = []
        for job, operations in jobs_data.items():
            if remaining_operations[job]:
                op_num = remaining_operations[job][0]
                machines, times = operations[op_num-1] # -1 to account for 0 indexing
                eligible_operations.append((job, op_num, machines, times))
        
        # If there are no eligible operations, break
        if not eligible_operations:
            break

        # Prioritize operations with the shortest processing time across machines
        best_operation = None
        min_processing_time = float('inf')

        for job, op_num, machines, times in eligible_operations:
            for m, t in zip(machines, times):
                if t < min_processing_time:
                    min_processing_time = t
                    best_operation = (job, op_num, m, t)

        if best_operation:
            job, op_num, machine, processing_time = best_operation

            start_time = max(machine_available_time[machine], job_completion_time[job])
            end_time = start_time + processing_time

            if job not in schedule:
                schedule[job] = []

            schedule[job].append({
                'Operation': op_num,
                'Assigned Machine': machine,
                'Start Time': start_time,
                'End Time': end_time,
                'Processing Time': processing_time
            })

            machine_available_time[machine] = end_time
            job_completion_time[job] = end_time

            remaining_operations[job].pop(0) # Remove the operation
            if not remaining_operations[job]:
                del remaining_operations[job]

    return schedule
