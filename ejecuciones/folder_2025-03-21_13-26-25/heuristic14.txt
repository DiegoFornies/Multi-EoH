
def heuristic(input_data):
    """
    A heuristic for solving the Flexible Job Shop Scheduling Problem (FJSP).

    This heuristic aims to minimize makespan, reduce time between operations in the same job,
    and balance machine load by considering machine availability and operation processing times.
    It prioritizes operations with shorter processing times and assigns them to machines that
    become available sooner, attempting to minimize overall completion time.
    """

    n_jobs = input_data['n_jobs']
    n_machines = input_data['n_machines']
    jobs = input_data['jobs']

    # Initialize data structures
    machine_available_time = {m: 0 for m in range(n_machines)}
    job_completion_time = {j: 0 for j in range(1, n_jobs + 1)}
    schedule = {j: [] for j in range(1, n_jobs + 1)}
    operation_queue = []  # List of (job, operation_index) tuples

    # Initialize operation queue with the first operation of each job
    for job in range(1, n_jobs + 1):
        operation_queue.append((job, 0))

    while operation_queue:
        # Sort operation queue based on shortest processing time on the first available machine
        operation_queue.sort(key=lambda x: min(
            input_data['jobs'][x[0]][x[1]][1][i]
            for i in range(len(input_data['jobs'][x[0]][x[1]][0]))
        ))

        job, operation_index = operation_queue.pop(0)
        machines, times = jobs[job][operation_index]

        # Find the machine that allows the earliest operation completion
        best_machine = None
        min_end_time = float('inf')
        processing_time = None

        for i, machine in enumerate(machines):
            start_time = max(machine_available_time[machine], job_completion_time[job])
            end_time = start_time + times[i]

            if end_time < min_end_time:
                min_end_time = end_time
                best_machine = machine
                processing_time = times[i]

        # Schedule the operation on the best machine
        start_time = max(machine_available_time[best_machine], job_completion_time[job])
        end_time = start_time + processing_time

        schedule[job].append({
            'Operation': operation_index + 1,
            'Assigned Machine': best_machine,
            'Start Time': start_time,
            'End Time': end_time,
            'Processing Time': processing_time
        })

        # Update machine availability and job completion time
        machine_available_time[best_machine] = end_time
        job_completion_time[job] = end_time

        # Add the next operation of the job to the queue, if any
        if operation_index + 1 < len(jobs[job]):
            operation_queue.append((job, operation_index + 1))

    return schedule
