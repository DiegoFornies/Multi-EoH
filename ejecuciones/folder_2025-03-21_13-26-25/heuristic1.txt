
def heuristic(input_data):
    """
    A heuristic for the Flexible Job Shop Scheduling Problem (FJSSP).

    This heuristic prioritizes jobs based on the total processing time of their operations
    and selects machines for operations based on earliest available time, trying to balance
    machine load and minimize idle time between operations of the same job.

    Args:
        input_data (dict): A dictionary describing the FJSSP instance.

    Returns:
        dict: A dictionary representing the schedule, with job numbers as keys and lists
              of operation schedules as values. Each operation schedule is a dictionary
              containing 'Operation', 'Assigned Machine', 'Start Time', 'End Time',
              and 'Processing Time'.
    """

    n_jobs = input_data['n_jobs']
    n_machines = input_data['n_machines']
    jobs_data = input_data['jobs']

    # Calculate total processing time for each job
    job_priorities = {}
    for job, operations in jobs_data.items():
        total_time = sum(min(times) for machines, times in operations)  # Use min time
        job_priorities[job] = total_time

    # Sort jobs by total processing time (longest first)
    sorted_jobs = sorted(job_priorities.keys(), key=job_priorities.get, reverse=True)

    # Initialize machine available times
    machine_available_times = {m: 0 for m in range(n_machines)}

    # Initialize the schedule
    schedule = {}

    for job in sorted_jobs:
        schedule[job] = []
        current_time = 0  # Time of the last operation completed for this job

        for op_num, (machines, times) in enumerate(jobs_data[job], 1):
            # Find the machine with the earliest available time among feasible machines
            best_machine = None
            earliest_start_time = float('inf')
            best_processing_time = float('inf')

            for i, machine in enumerate(machines):
                available_time = machine_available_times[machine]
                start_time = max(available_time, current_time)

                if start_time < earliest_start_time:
                    earliest_start_time = start_time
                    best_machine = machine
                    best_processing_time = times[i]  # Correct processing time

                elif start_time == earliest_start_time and times[i] < best_processing_time: # Tie-breaking
                    best_machine = machine
                    best_processing_time = times[i]

            # Schedule the operation on the chosen machine
            start_time = max(machine_available_times[best_machine], current_time)
            end_time = start_time + best_processing_time
            schedule[job].append({
                'Operation': op_num,
                'Assigned Machine': best_machine,
                'Start Time': start_time,
                'End Time': end_time,
                'Processing Time': best_processing_time
            })

            # Update machine available time and job completion time
            machine_available_times[best_machine] = end_time
            current_time = end_time

    return schedule
