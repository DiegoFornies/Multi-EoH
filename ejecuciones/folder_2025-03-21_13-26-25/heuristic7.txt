
def heuristic(input_data):
    """
    A heuristic algorithm for solving the Flexible Job Shop Scheduling Problem (FJSP).

    This heuristic aims to minimize makespan and balance machine load by considering
    shortest processing time and earliest start time when assigning operations to machines.

    Args:
        input_data (dict): A dictionary containing the problem definition.

    Returns:
        dict: A dictionary representing the schedule, where keys are job numbers and
              values are lists of dictionaries, each representing an operation's schedule.
    """

    n_jobs = input_data['n_jobs']
    n_machines = input_data['n_machines']
    jobs_data = input_data['jobs']

    # Initialize data structures
    machine_available_time = {m: 0 for m in range(n_machines)}
    job_completion_time = {j: 0 for j in range(1, n_jobs + 1)}  # Start jobs from 1, not 0
    schedule = {j: [] for j in range(1, n_jobs + 1)}
    machine_load = {m: [] for m in range(n_machines)}  # Store operations assigned to each machine

    # Prioritize operations based on shortest processing time and earliest job completion
    operations_queue = []
    for job, operations in jobs_data.items():
        for op_idx, (machines, times) in enumerate(operations):
            operations_queue.append((job, op_idx, machines, times))

    # Sort operations by shortest processing time first
    operations_queue.sort(key=lambda x: min(x[3]))

    # Iterate through the operations queue and assign operations to machines
    while operations_queue:
        job, op_idx, machines, times = operations_queue.pop(0)
        
        # Find the best machine for the operation
        best_machine, best_start_time, best_processing_time = None, float('inf'), None

        for m_idx, machine in enumerate(machines):
            processing_time = times[m_idx]
            start_time = max(machine_available_time[machine], job_completion_time[job])

            if start_time < best_start_time:
                best_start_time = start_time
                best_machine = machine
                best_processing_time = processing_time
        
        # Assign the operation to the chosen machine
        start_time = best_start_time
        end_time = start_time + best_processing_time
        machine = best_machine

        schedule[job].append({
            'Operation': op_idx + 1,
            'Assigned Machine': machine,
            'Start Time': start_time,
            'End Time': end_time,
            'Processing Time': best_processing_time
        })

        # Update machine available time and job completion time
        machine_available_time[machine] = end_time
        job_completion_time[job] = end_time
        machine_load[machine].append((job, op_idx + 1, start_time, end_time))

    return schedule
