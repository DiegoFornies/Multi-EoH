
def heuristic(input_data):
    """
    A heuristic for solving the Flexible Job Shop Scheduling Problem (FJSSP).

    This heuristic prioritizes jobs based on the total processing time of their
    operations and assigns operations to machines with the earliest available time,
    considering both machine availability and job sequence constraints. It also
    tries to balance the load across machines by occasionally choosing a less
    busy machine, even if it means a slightly later start time for an operation.
    """

    n_jobs = input_data['n_jobs']
    n_machines = input_data['n_machines']
    jobs_data = input_data['jobs']

    # Calculate total processing time for each job
    job_priorities = {}
    for job, ops in jobs_data.items():
        total_time = sum(min(times) for machines, times in ops)  # Use min time available to consider flexibility
        job_priorities[job] = total_time

    # Sort jobs based on total processing time (longest first)
    sorted_jobs = sorted(job_priorities.items(), key=lambda item: item[1], reverse=True)

    # Initialize schedule and machine availability
    schedule = {}
    machine_availability = {m: 0 for m in range(n_machines)}
    job_completion_times = {job: 0 for job in range(1, n_jobs + 1)} #Completion Time of each job
    operation_counter = {job: 0 for job in range(1, n_jobs + 1)} # Keep track of operations within a job

    # Schedule operations
    for job, _ in sorted_jobs:
        schedule[job] = []
        current_job_completion_time = job_completion_times[job]
        
        for op_index, operation_data in enumerate(jobs_data[job]):
            machines, times = operation_data
            
            operation_number = operation_counter[job] + 1
            operation_counter[job] = operation_number
            
            best_machine = None
            earliest_start_time = float('inf')
            best_processing_time = None
            
            # Find the best machine for the operation, considering both machine and job sequence constraints
            for machine_index, machine in enumerate(machines):
                processing_time = times[machine_index]
                available_time_on_machine = machine_availability[machine]
                start_time = max(available_time_on_machine, current_job_completion_time)
                
                if start_time < earliest_start_time:
                    earliest_start_time = start_time
                    best_machine = machine
                    best_processing_time = processing_time

            #Enforce that machine cannot be None
            if best_machine is None:
                best_machine = machines[0]
                best_processing_time = times[0]
                earliest_start_time = max(machine_availability[best_machine], current_job_completion_time)
                
            #Introduce a load balancing element, penalize the machine selected if it is busy
            
            current_machine_load = machine_availability[best_machine]
            # Select a different machine in 1/3 of the times if there are other options that can improve balance.
            if len(machines) > 1 and current_machine_load > 0 and (op_index % 3 != 0): #Only balance if there are options.
                for machine_index, machine in enumerate(machines):
                    if machine == best_machine:
                        continue
                    
                    processing_time = times[machine_index]
                    available_time_on_machine = machine_availability[machine]
                    start_time = max(available_time_on_machine, current_job_completion_time)

                    #Consider only the alternative machine if the makespan is not increased by more than 10% and is more balanced.
                    if start_time < (earliest_start_time * 1.1) and machine_availability[machine] < current_machine_load:
                        best_machine = machine
                        best_processing_time = processing_time
                        earliest_start_time = start_time
                        break

            # Assign the operation to the chosen machine
            start_time = earliest_start_time
            end_time = start_time + best_processing_time

            schedule[job].append({
                'Operation': operation_number,
                'Assigned Machine': best_machine,
                'Start Time': start_time,
                'End Time': end_time,
                'Processing Time': best_processing_time
            })

            # Update machine availability and job completion time
            machine_availability[best_machine] = end_time
            current_job_completion_time = end_time
            job_completion_times[job] = current_job_completion_time

    return schedule
