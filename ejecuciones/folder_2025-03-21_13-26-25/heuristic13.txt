
def heuristic(input_data):
    """
    A heuristic algorithm for solving the Flexible Job Shop Scheduling Problem (FJSP).
    This heuristic considers machine load balancing and job completion time in a greedy manner.
    """
    n_jobs = input_data['n_jobs']
    n_machines = input_data['n_machines']
    jobs = input_data['jobs']

    # Initialize data structures
    machine_available_time = {m: 0 for m in range(n_machines)}
    job_completion_time = {job: 0 for job in range(1, n_jobs + 1)}
    schedule = {job: [] for job in range(1, n_jobs + 1)}
    machine_loads = {m: [] for m in range(n_machines)} # Store tuples (start_time, end_time)

    # Iterate through jobs and operations
    for job in range(1, n_jobs + 1):
        for op_idx, operation in enumerate(jobs[job]):
            machines, times = operation
            best_machine, best_time = None, float('inf')

            # Find the best machine for the current operation
            for m_idx, machine in enumerate(machines):
                processing_time = times[m_idx]
                start_time = max(machine_available_time[machine], job_completion_time[job])

                #Check machine overload
                machine_free = True
                for start, end in machine_loads[machine]:
                    if not (start_time >= end or start_time + processing_time <= start):
                        machine_free = False
                        break

                if machine_free:
                    if start_time + processing_time < best_time:
                            best_time = start_time + processing_time
                            best_machine = machine

            # Schedule the operation on the best machine
            if best_machine is not None:
                start_time = max(machine_available_time[best_machine], job_completion_time[job])
                end_time = start_time + times[machines.index(best_machine)]
                processing_time = times[machines.index(best_machine)]
                
                schedule[job].append({
                    'Operation': op_idx + 1,
                    'Assigned Machine': best_machine,
                    'Start Time': start_time,
                    'End Time': end_time,
                    'Processing Time': processing_time
                })

                # Update machine and job completion times
                machine_available_time[best_machine] = end_time
                job_completion_time[job] = end_time
                machine_loads[best_machine].append((start_time, end_time))
                machine_loads[best_machine].sort() #Keep the scheduled times in order
            else:
                # Handle the case where no machine is available (very unlikely, but good to handle)
                # For example, reschedule the job later or assign a random machine
                # For simplicity, let's raise an exception for now
                raise Exception(f"No suitable machine found for job {job}, operation {op_idx + 1}")

    return schedule
