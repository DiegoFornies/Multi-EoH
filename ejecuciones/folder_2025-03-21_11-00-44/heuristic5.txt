
def heuristic(input_data):
    """
    A heuristic algorithm for solving the Flexible Job Shop Scheduling Problem (FJSP).
    This heuristic prioritizes minimizing makespan and balancing machine load by
    considering the shortest processing time and least loaded machine for each operation.
    """
    n_jobs = input_data['n_jobs']
    n_machines = input_data['n_machines']
    jobs = input_data['jobs']

    # Initialize schedule and machine available times
    schedule = {}
    machine_available_time = {m: 0 for m in range(n_machines)}
    job_completion_time = {j: 0 for j in range(1, n_jobs + 1)}  # Initialize completion times for each job
    
    # Create a list of operations and their possible machines
    operations = []
    for job_id, job_ops in jobs.items():
        for op_idx, op_data in enumerate(job_ops):
            operations.append({
                'job_id': job_id,
                'op_idx': op_idx + 1,  # Operation number (1-indexed)
                'machines': op_data[0],
                'times': op_data[1]
            })
    
    # Sort operations by the shortest processing time across available machines
    operations.sort(key=lambda op: min(op['times']))

    # Assign operations to machines
    for operation in operations:
        job_id = operation['job_id']
        op_idx = operation['op_idx']
        machines = operation['machines']
        times = operation['times']

        # Find the machine with the earliest available time among feasible machines
        best_machine = None
        min_end_time = float('inf')
        best_processing_time = None

        for i, machine in enumerate(machines):
            processing_time = times[i]
            start_time = max(machine_available_time[machine], job_completion_time[job_id]) #Job must start after its prev operation
            end_time = start_time + processing_time

            if end_time < min_end_time:
                min_end_time = end_time
                best_machine = machine
                best_processing_time = processing_time

        # Schedule the operation on the best machine
        start_time = max(machine_available_time[best_machine], job_completion_time[job_id]) #Job must start after its prev operation
        end_time = start_time + best_processing_time
        
        if job_id not in schedule:
            schedule[job_id] = []

        schedule[job_id].append({
            'Operation': op_idx,
            'Assigned Machine': best_machine,
            'Start Time': start_time,
            'End Time': end_time,
            'Processing Time': best_processing_time
        })

        # Update machine and job completion times
        machine_available_time[best_machine] = end_time
        job_completion_time[job_id] = end_time

    return schedule
