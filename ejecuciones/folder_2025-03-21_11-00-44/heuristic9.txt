
def heuristic(input_data):
    """
    A heuristic algorithm for the Flexible Job Shop Scheduling Problem (FJSSP).

    This heuristic aims to minimize makespan while considering operation feasibility,
    machine feasibility, and sequence feasibility. It prioritizes operations
    based on the shortest processing time among available machines and jobs.
    It also tries to balance the load across machines.
    """

    n_jobs = input_data['n_jobs']
    n_machines = input_data['n_machines']
    jobs_data = input_data['jobs']

    # Initialize data structures
    schedule = {}
    machine_available_time = {m: 0 for m in range(n_machines)}
    job_completion_time = {j: 0 for j in range(1, n_jobs + 1)}  # job completion times
    operation_queue = []  # Priority queue for operations (job, operation_index, possible_machines)
    scheduled_operations = {}

    # Initial population of the operation queue
    for job_id, operations in jobs_data.items():
        operation_queue.append((job_id, 0, operations[0][0]))  # (job, index, possible_machines)

    import heapq
    # Main scheduling loop
    while operation_queue:
        # Find the operation with the shortest processing time on an available machine
        best_job, best_op_idx, best_machine, best_processing_time = None, None, None, float('inf')
        job_to_remove = None
        
        for i, (job_id, op_idx, possible_machines) in enumerate(operation_queue):
            available_machines = possible_machines
            processing_times = [jobs_data[job_id][op_idx][1][jobs_data[job_id][op_idx][0].index(machine)] for machine in available_machines]

            for machine_index, machine in enumerate(available_machines):
                processing_time = processing_times[machine_index]
                available_time = max(machine_available_time[machine], job_completion_time[job_id])
                
                if available_time + processing_time < best_processing_time:
                    best_job, best_op_idx, best_machine, best_processing_time = job_id, op_idx, machine, available_time + processing_time
                    job_to_remove = i
        
        # Schedule the best operation
        job_id = best_job
        op_idx = best_op_idx
        machine = best_machine
        processing_time = [jobs_data[job_id][op_idx][1][jobs_data[job_id][op_idx][0].index(machine)] for machine in [machine]][0]
        start_time = max(machine_available_time[machine], job_completion_time[job_id])
        end_time = start_time + processing_time

        if job_id not in schedule:
            schedule[job_id] = []

        schedule[job_id].append({
            'Operation': op_idx + 1,
            'Assigned Machine': machine,
            'Start Time': start_time,
            'End Time': end_time,
            'Processing Time': processing_time
        })
            
        machine_available_time[machine] = end_time
        job_completion_time[job_id] = end_time
        
        del operation_queue[job_to_remove] #remove the scheduled job from the queue

        # Add the next operation for the job to the queue, if any
        next_op_idx = op_idx + 1
        if next_op_idx < len(jobs_data[job_id]):
            operation_queue.append((job_id, next_op_idx, jobs_data[job_id][next_op_idx][0]))
    
    return schedule
