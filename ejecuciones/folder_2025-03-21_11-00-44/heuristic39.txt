
def heuristic(data):
    """
    Schedules jobs on machines to minimize makespan and balance machine load,
    considering operation and machine feasibility, and sequence constraints.

    Args:
        data (dict): A dictionary containing the job and machine information.

    Returns:
        dict: A dictionary representing the schedule, with job numbers as keys
              and a list of operation details as values.
    """

    n_jobs = data['n_jobs']
    n_machines = data['n_machines']
    jobs = data['jobs']

    # Initialize schedule and machine availability
    schedule = {}
    machine_available_time = {m: 0 for m in range(1, n_machines + 1)}

    # Iterate through jobs and operations, scheduling greedily
    for job_id in jobs:
        schedule[job_id] = []
        current_time = 0  # Start each job at time 0 initially, updated as operations are scheduled.
        for operation_index, operation in enumerate(jobs[job_id]):
            machines, times = operation
            best_machine = None
            min_end_time = float('inf')
            processing_time = None

            # Find the best machine for the current operation
            for i, machine in enumerate(machines):
                available_time = machine_available_time[machine]
                end_time = max(current_time, available_time) + times[i]

                if end_time < min_end_time:
                    min_end_time = end_time
                    best_machine = str(machine)  # Store as string for consistency with example
                    processing_time = times[i]

            # Assign the operation to the best machine
            start_time = max(current_time, machine_available_time[int(best_machine)])
            end_time = start_time + processing_time
            schedule[job_id].append({
                'Operation': operation_index + 1,
                'Assigned Machine': best_machine,
                'Start Time': start_time,
                'End Time': end_time,
                'Processing Time': processing_time
            })

            # Update machine availability and current time for the job
            machine_available_time[int(best_machine)] = end_time
            current_time = end_time # Advance job's current time to the end of the last operation.

    return schedule
