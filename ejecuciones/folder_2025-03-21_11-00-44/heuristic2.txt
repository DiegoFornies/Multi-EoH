
def heuristic(input_data):
    """
    A heuristic for solving the Flexible Job Shop Scheduling Problem (FJSP).
    This heuristic prioritizes assigning operations to machines with the earliest
    available time, considering both machine availability and job dependencies.
    It also incorporates a simple load balancing strategy by penalizing machines
    that are already heavily loaded.
    """
    n_jobs = input_data['n_jobs']
    n_machines = input_data['n_machines']
    jobs = input_data['jobs']

    # Initialize data structures
    machine_available_time = {m: 0 for m in range(n_machines)}
    job_completion_time = {j: 0 for j in range(1, n_jobs + 1)}
    machine_load = {m: 0 for m in range(n_machines)}  # Keep track of machine load
    schedule = {}

    # Iterate through jobs
    for job in range(1, n_jobs + 1):
        schedule[job] = []
        operations = jobs[job]

        # Iterate through operations in the job
        for op_idx, operation in enumerate(operations):
            machines = operation[0]
            times = operation[1]

            # Find the best machine to assign the operation to
            best_machine = None
            min_end_time = float('inf')

            for m_idx, machine in enumerate(machines):
                processing_time = times[m_idx]
                start_time = max(machine_available_time[machine], job_completion_time[job])
                end_time = start_time + processing_time
                
                # Penalize heavily loaded machines
                load_penalty = machine_load[machine] * 0.1  # Adjust penalty factor as needed
                
                if end_time + load_penalty < min_end_time:
                    min_end_time = end_time + load_penalty
                    best_machine = machine
                    best_start_time = start_time
                    best_processing_time = processing_time

            # Assign the operation to the best machine
            schedule[job].append({
                'Operation': op_idx + 1,
                'Assigned Machine': best_machine,
                'Start Time': best_start_time,
                'End Time': best_start_time + best_processing_time,
                'Processing Time': best_processing_time
            })

            # Update machine availability and job completion time
            machine_available_time[best_machine] = best_start_time + best_processing_time
            job_completion_time[job] = best_start_time + best_processing_time
            machine_load[best_machine] += best_processing_time  # Update machine load

    return schedule
