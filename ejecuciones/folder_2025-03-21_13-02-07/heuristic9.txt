
def heuristic(input_data):
    """
    A heuristic algorithm for solving the Flexible Job Shop Scheduling Problem (FJSSP).

    This heuristic prioritizes minimizing makespan by considering machine load balancing
    and reducing idle time between operations of the same job. It uses a priority rule
    based on the shortest processing time among available machines for an operation.

    Args:
        input_data (dict): A dictionary containing the problem instance data, including
                           the number of jobs, number of machines, and job operation details.

    Returns:
        dict: A dictionary representing the schedule, where each key is a job number,
              and the value is a list of dictionaries containing operation details
              (assigned machine, start time, end time, processing time).
    """

    n_jobs = input_data['n_jobs']
    n_machines = input_data['n_machines']
    jobs_data = input_data['jobs']

    # Initialize data structures
    schedule = {}  # Store the final schedule
    machine_available_time = {m: 0 for m in range(n_machines)}  # Track when each machine is available
    job_completion_time = {j: 0 for j in range(1, n_jobs + 1)}  # Track the completion time of each job
    job_operations_done = {j: 0 for j in range(1, n_jobs + 1)}  # Track the number of operations completed for each job

    # Create a list of operations, sorted by job number and operation sequence
    operations = []
    for job_id, job_ops in jobs_data.items():
        for op_idx, op_data in enumerate(job_ops):
            operations.append((job_id, op_idx + 1, op_data))  # (job_id, operation_index, operation_data)

    # Create set to track which operations have been scheduled
    scheduled_operations = set()

    # Schedule operations until all are scheduled
    while len(scheduled_operations) < len(operations):
        # Find schedulable operations (not yet scheduled, and previous operation completed for the same job)
        available_operations = []
        for job_id, op_idx, op_data in operations:
            if (job_id, op_idx) not in scheduled_operations:
                if op_idx == 1 or (job_id, op_idx - 1) in scheduled_operations: # Check for sequence feasibility
                    available_operations.append((job_id, op_idx, op_data))
        
        # If no operations are available, this means that an impossible operation order exist
        if not available_operations:
            return "No solution found" # No operations are available, there might be an error on job sequence

        # Select the best operation based on the Shortest Processing Time (SPT) rule among available machines
        best_operation = None
        min_end_time = float('inf')

        for job_id, op_idx, op_data in available_operations:
            machines, times = op_data
            
            # Find the machine that allows the operation to finish earliest, considering machine and job availability
            best_machine = None
            best_time = float('inf')
            best_processing_time = None
            
            for machine_idx, machine in enumerate(machines):
                processing_time = times[machine_idx]
                start_time = max(machine_available_time[machine], job_completion_time[job_id])
                end_time = start_time + processing_time
                
                if end_time < best_time:
                    best_time = end_time
                    best_machine = machine
                    best_processing_time = processing_time
                    
            # Update the best operation found
            if best_time < min_end_time:
                min_end_time = best_time
                best_operation = (job_id, op_idx, best_machine, best_time - best_processing_time, best_time, best_processing_time)

        # Schedule the selected operation
        job_id, op_idx, assigned_machine, start_time, end_time, processing_time = best_operation

        if job_id not in schedule:
            schedule[job_id] = []

        schedule[job_id].append({
            'Operation': op_idx,
            'Assigned Machine': assigned_machine,
            'Start Time': start_time,
            'End Time': end_time,
            'Processing Time': processing_time
        })

        # Update data structures
        machine_available_time[assigned_machine] = end_time
        job_completion_time[job_id] = end_time
        job_operations_done[job_id] += 1
        scheduled_operations.add((job_id, op_idx))

    return schedule
