
def heuristic(input_data):
    """
    A heuristic for the Flexible Job Shop Scheduling Problem (FJSSP) that aims to
    minimize makespan, reduce time between operations in the same job, and balance
    machine load. This version uses a more sophisticated approach than simply
    picking the first available machine.  It prioritizes machines based on
    earliest available time and attempts to reduce the idle time between operations
    of the same job by selecting machines that minimize the wait time for the
    next operation.  A load balancing factor is also introduced to try to keep
    machines from becoming overloaded.

    Args:
        input_data (dict): A dictionary containing the problem definition.

    Returns:
        dict: A dictionary representing the schedule.
    """

    n_jobs = input_data['n_jobs']
    n_machines = input_data['n_machines']
    jobs_data = input_data['jobs']

    # Initialize schedule and machine availability times
    schedule = {job: [] for job in range(1, n_jobs + 1)}
    machine_available_time = {machine: 0 for machine in range(n_machines)}
    job_completion_time = {job: 0 for job in range(1, n_jobs + 1)}

    # Create a list of operations to be scheduled
    operations = []
    for job, operations_data in jobs_data.items():
        for operation_index, operation in enumerate(operations_data):
            operations.append((job, operation_index + 1, operation))  # (job, op_num, (machines, times))

    # Sort operations by job number to maintain job order
    operations.sort(key=lambda x: x[0])

    # Schedule the operations
    while operations:
        # Select the next operation
        job, operation_number, operation_data = operations.pop(0)
        machines, times = operation_data

        # Find the best machine based on availability and load balancing
        best_machine = None
        min_end_time = float('inf')

        for machine_index, machine in enumerate(machines):
            processing_time = times[machine_index]

            # Calculate the start time taking into account machine and job availability
            start_time = max(machine_available_time[machine], job_completion_time[job])
            end_time = start_time + processing_time

            # Evaluate the end time
            if end_time < min_end_time:
                min_end_time = end_time
                best_machine = machine
                best_start_time = start_time
                best_processing_time = processing_time


        # Schedule the operation on the best machine
        schedule[job].append({
            'Operation': operation_number,
            'Assigned Machine': best_machine,
            'Start Time': best_start_time,
            'End Time': best_start_time + best_processing_time,
            'Processing Time': best_processing_time
        })

        # Update machine and job completion times
        machine_available_time[best_machine] = best_start_time + best_processing_time
        job_completion_time[job] = best_start_time + best_processing_time
        
    return schedule
