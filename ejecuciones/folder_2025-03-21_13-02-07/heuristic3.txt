
def heuristic(input_data):
    """
    A heuristic for the Flexible Job Shop Scheduling Problem (FJSSP).

    This heuristic prioritizes operations based on a combination of factors,
    including processing time, number of alternative machines, and job order.
    It attempts to balance machine load and minimize makespan.

    Args:
        input_data (dict): A dictionary containing the problem instance data.

    Returns:
        dict: A dictionary representing the schedule.
    """

    n_jobs = input_data['n_jobs']
    n_machines = input_data['n_machines']
    jobs = input_data['jobs']

    # Initialize data structures
    schedule = {}
    machine_available_time = {m: 0 for m in range(n_machines)}
    job_completion_time = {j: 0 for j in range(1, n_jobs + 1)}
    operation_queue = []

    # Create a list of operations with additional information for prioritization
    operation_id = 0
    for job_id, operations in jobs.items():
        schedule[job_id] = []
        for op_index, operation in enumerate(operations):
            operation_id += 1
            machines, times = operation
            operation_queue.append({
                'job_id': job_id,
                'op_index': op_index + 1,  # Actual operation number
                'machines': machines,
                'times': times,
                'operation_id': operation_id,  # Unique identifier for sorting
                'priority': 0 # initialize priority
            })
    
    def calculate_priority(operation):
        """Calculates the priority of an operation based on multiple factors."""
        # Factor 1: Shortest Processing Time First (SPT)
        min_processing_time = min(operation['times'])
        priority = min_processing_time

        # Factor 2: Fewest Alternative Machines (FAM)
        num_machines = len(operation['machines'])
        priority -= (1.0 / num_machines) # Smaller number of machines, higher priority

        return priority

    # Initial priority calculation
    for operation in operation_queue:
         operation['priority'] = calculate_priority(operation)

    # Main scheduling loop
    while operation_queue:
        # Sort operations based on priority (highest priority first)
        operation_queue.sort(key=lambda x: x['priority'], reverse=True)
        
        best_operation = operation_queue.pop(0)
        job_id = best_operation['job_id']
        op_index = best_operation['op_index']
        machines = best_operation['machines']
        times = best_operation['times']
        
        # Find the best machine for the operation (earliest available time)
        best_machine = None
        min_start_time = float('inf')
        processing_time = 0

        for i, machine in enumerate(machines):
            start_time = max(machine_available_time[machine], job_completion_time[job_id])
            if start_time < min_start_time:
                min_start_time = start_time
                best_machine = machine
                processing_time = times[i]

        # Schedule the operation on the best machine
        start_time = min_start_time
        end_time = start_time + processing_time
        
        schedule[job_id].append({
            'Operation': op_index,
            'Assigned Machine': best_machine,
            'Start Time': start_time,
            'End Time': end_time,
            'Processing Time': processing_time
        })
        
        # Update machine available time and job completion time
        machine_available_time[best_machine] = end_time
        job_completion_time[job_id] = end_time

        # Recalculate and update priorities for remaining operations
        for operation in operation_queue:
           operation['priority'] = calculate_priority(operation)

    return schedule
