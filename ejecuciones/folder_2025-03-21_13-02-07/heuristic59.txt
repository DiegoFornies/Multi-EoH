
import heapq

def heuristic(data):
    """
    Heuristic for the Flexible Job Shop Scheduling Problem (FJSSP).

    This heuristic prioritizes minimizing makespan while attempting to balance
    machine load and reduce idle time between operations of the same job.

    Args:
        data (dict): A dictionary containing the problem data, including the
                     number of jobs, number of machines, and job operation details.

    Returns:
        dict: A dictionary representing the schedule, where each key is a job number
              and the value is a list of dictionaries, each containing the
              scheduling information for an operation.
    """

    n_jobs = data['n_jobs']
    n_machines = data['n_machines']
    jobs = data['jobs']

    # Initialize machine availability times.
    machine_available_time = {m: 0 for m in range(1, n_machines + 1)}

    # Initialize job completion times.
    job_completion_time = {j: 0 for j in range(1, n_jobs + 1)}

    # Initialize the schedule.
    schedule = {j: [] for j in range(1, n_jobs + 1)}

    # Create a priority queue for operations, prioritizing operations with
    # shorter processing times and earlier job completion times.  This helps
    # to both reduce makespan and improve job flow.
    operation_queue = []
    for job_id, operations in jobs.items():
        if operations:
            # Push the first operation of each job onto the queue.
            machines, times = operations[0]
            min_time = min(times)  # Prioritize shortest processing time.
            heapq.heappush(operation_queue, (min_time + job_completion_time[job_id], min_time, job_id, 0))
    
    while operation_queue:
        _, processing_time, job_id, operation_index = heapq.heappop(operation_queue)
        operation = jobs[job_id][operation_index]
        possible_machines = operation[0]
        possible_times = operation[1]

        # Find the machine that allows the earliest completion time for this operation,
        # taking into account both machine availability and job completion time
        # of the previous operation for this job. This helps reduce the overall makespan.
        best_machine = None
        earliest_start_time = float('inf')
        best_processing_time = None

        for i, machine in enumerate(possible_machines):
            start_time = max(machine_available_time[machine], job_completion_time[job_id])
            if start_time < earliest_start_time:
                earliest_start_time = start_time
                best_machine = str(machine)
                best_processing_time = possible_times[i]

        # Schedule the operation on the selected machine.
        start_time = earliest_start_time
        end_time = start_time + best_processing_time

        schedule[job_id].append({
            'Operation': operation_index + 1,
            'Assigned Machine': best_machine,
            'Start Time': start_time,
            'End Time': end_time,
            'Processing Time': best_processing_time
        })

        # Update machine availability and job completion time.
        machine = int(best_machine)
        machine_available_time[machine] = end_time
        job_completion_time[job_id] = end_time

        # Add the next operation of this job to the queue, if any.
        next_operation_index = operation_index + 1
        if next_operation_index < len(jobs[job_id]):
            next_operation = jobs[job_id][next_operation_index]
            machines, times = next_operation
            min_time = min(times)
            heapq.heappush(operation_queue, (min_time + job_completion_time[job_id], min_time, job_id, next_operation_index))

    return schedule
