
def heuristic(input_data):
    """
    A heuristic for the Flexible Job Shop Scheduling Problem (FJSSP).

    This heuristic prioritizes minimizing makespan by considering machine load
    and operation processing times. It iterates through jobs and their operations,
    assigning operations to machines that minimize the completion time of the
    operation, considering both machine availability and job dependencies.

    Args:
        input_data (dict): A dictionary containing the problem instance data,
                           including the number of jobs, machines, and
                           operation details.

    Returns:
        dict: A dictionary representing the schedule, where each key is a job
              number and the value is a list of dictionaries, each describing
              an operation with assigned machine, start time, end time, and
              processing time.
    """

    n_jobs = input_data['n_jobs']
    n_machines = input_data['n_machines']
    jobs = input_data['jobs']

    # Initialize data structures
    schedule = {}
    machine_available_time = {m: 0 for m in range(n_machines)}
    job_completion_time = {j: 0 for j in range(1, n_jobs + 1)}

    # Iterate through jobs
    for job_id in range(1, n_jobs + 1):
        schedule[job_id] = []
        operations = jobs[job_id]

        # Iterate through operations of the current job
        for operation_index, operation in enumerate(operations, 1):
            possible_machines = operation[0]
            possible_times = operation[1]

            # Find the machine that allows the earliest completion time
            best_machine = None
            min_completion_time = float('inf')

            for machine_index, machine_id in enumerate(possible_machines):
                processing_time = possible_times[machine_index]

                # Calculate the earliest possible start time based on machine and job availability
                start_time = max(machine_available_time[machine_id], job_completion_time[job_id])
                completion_time = start_time + processing_time

                if completion_time < min_completion_time:
                    min_completion_time = completion_time
                    best_machine = machine_id
                    best_processing_time = processing_time  # Store the best processing time as well

            # Assign the operation to the best machine
            start_time = max(machine_available_time[best_machine], job_completion_time[job_id])
            end_time = start_time + best_processing_time

            schedule[job_id].append({
                'Operation': operation_index,
                'Assigned Machine': best_machine,
                'Start Time': start_time,
                'End Time': end_time,
                'Processing Time': best_processing_time
            })

            # Update machine and job completion times
            machine_available_time[best_machine] = end_time
            job_completion_time[job_id] = end_time

    return schedule
