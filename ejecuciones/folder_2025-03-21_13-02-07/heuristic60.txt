
def heuristic(data):
    """
    A heuristic to solve the Flexible Job Shop Scheduling Problem (FJSP).

    This heuristic focuses on minimizing makespan while considering machine load
    balance and operation separation. It prioritizes operations with fewer
    machine options and shorter processing times.

    Args:
        data (dict): A dictionary containing the problem data, including
            n_jobs, n_machines, and jobs.

    Returns:
        dict: A dictionary representing the schedule, where keys are job numbers
            and values are lists of dictionaries containing operation details
            (Operation, Assigned Machine, Start Time, End Time, Processing Time).
    """

    n_jobs = data['n_jobs']
    n_machines = data['n_machines']
    jobs = data['jobs']

    # Initialize the schedule
    schedule = {job: [] for job in range(1, n_jobs + 1)}

    # Initialize machine availability times
    machine_availability = {machine: 0 for machine in range(1, n_machines + 1)}

    # Initialize job completion times
    job_completion_times = {job: 0 for job in range(1, n_jobs + 1)}

    # Create a list of operations to be scheduled
    operations = []
    for job in jobs:
        for i, operation in enumerate(jobs[job]):
            operations.append({
                'job': job,
                'operation_index': i,
                'machines': operation[0],
                'processing_times': operation[1]
            })

    # Sort operations by the number of available machines (fewer first)
    operations.sort(key=lambda x: len(x['machines']))

    # Schedule the operations
    for operation_data in operations:
        job = operation_data['job']
        operation_index = operation_data['operation_index']
        machines = operation_data['machines']
        processing_times = operation_data['processing_times']

        # Find the earliest available time on a suitable machine
        best_machine = None
        earliest_start_time = float('inf')
        best_processing_time = None  # Initialize best_processing_time

        for i, machine in enumerate(machines):
            processing_time = processing_times[i]
            start_time = max(machine_availability[machine], job_completion_times[job])

            if start_time < earliest_start_time:
                earliest_start_time = start_time
                best_machine = str(machine)  # Store machine as string
                best_processing_time = processing_time

        # Schedule the operation on the best machine
        start_time = earliest_start_time
        end_time = start_time + best_processing_time

        schedule[job].append({
            'Operation': operation_index + 1,
            'Assigned Machine': best_machine,
            'Start Time': start_time,
            'End Time': end_time,
            'Processing Time': best_processing_time
        })

        # Update machine availability and job completion time
        machine_availability[int(best_machine)] = end_time # Convert back to int
        job_completion_times[job] = end_time

    return schedule
