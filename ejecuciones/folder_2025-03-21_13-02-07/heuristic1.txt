
def heuristic(input_data):
    """
    A heuristic for the Flexible Job Shop Scheduling Problem (FJSSP).

    This heuristic aims to minimize makespan and balance machine load by
    prioritizing operations with shorter processing times and assigning them
    to machines that are currently less loaded. It considers operation feasibility,
    machine feasibility, and sequence feasibility.
    """

    n_jobs = input_data['n_jobs']
    n_machines = input_data['n_machines']
    jobs_data = input_data['jobs']

    # Initialize data structures
    schedule = {}
    machine_available_time = {m: 0 for m in range(n_machines)}  # When each machine is available
    job_completion_time = {j: 0 for j in range(1, n_jobs + 1)} # When each job can continue

    # Create a list of operations sorted by shortest processing time
    operations = []
    for job, ops in jobs_data.items():
        for op_idx, (machines, times) in enumerate(ops):
            min_time_idx = times.index(min(times))  # Choose shortest processing time
            operations.append({
                'job': job,
                'operation': op_idx + 1,
                'machines': machines,
                'times': times,
                'min_machine_idx': min_time_idx,
                'processing_time': times[min_time_idx]  # Minimum processing time
            })

    operations.sort(key=lambda x: x['processing_time']) # Sort by processing time

    # Schedule operations
    for operation in operations:
        job = operation['job']
        op_num = operation['operation']
        machines = operation['machines']
        times = operation['times']
        min_machine_idx = operation['min_machine_idx']

        # Find the earliest available machine among the feasible ones
        best_machine = None
        start_time = float('inf')
        processing_time = float('inf')

        for i, machine in enumerate(machines):

            # Calculate start time based on machine and job availability
            current_start_time = max(machine_available_time[machine], job_completion_time[job])
            current_processing_time = times[i]

            if current_start_time < start_time:
                start_time = current_start_time
                best_machine = machine
                processing_time = current_processing_time

        # Update schedule
        end_time = start_time + processing_time

        if job not in schedule:
            schedule[job] = []

        schedule[job].append({
            'Operation': op_num,
            'Assigned Machine': best_machine,
            'Start Time': start_time,
            'End Time': end_time,
            'Processing Time': processing_time
        })

        # Update machine and job availability
        machine_available_time[best_machine] = end_time
        job_completion_time[job] = end_time

    return schedule
