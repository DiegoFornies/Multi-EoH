
def heuristic(input_data):
    """
    A heuristic algorithm for the Flexible Job Shop Scheduling Problem (FJSSP).

    This heuristic aims to minimize makespan by considering machine load and operation processing times.
    It prioritizes assigning operations to machines with earlier available times and shorter processing times.
    It also attempts to minimize the idle time between operations of the same job.

    Args:
        input_data (dict): A dictionary containing the problem data, including the number of jobs,
                           the number of machines, and the job details (operations, available machines,
                           and processing times).

    Returns:
        dict: A dictionary representing the schedule, where each key is a job number and the value
              is a list of dictionaries, each representing an operation with assigned machine,
              start time, end time, and processing time.
    """

    n_jobs = input_data['n_jobs']
    n_machines = input_data['n_machines']
    jobs_data = input_data['jobs']

    schedule = {}
    machine_available_times = {m: 0 for m in range(n_machines)}
    job_completion_times = {j: 0 for j in range(1, n_jobs + 1)}

    # Create a list of operations with their possible machines and times
    operations_list = []
    for job_id, operations in jobs_data.items():
        for op_idx, (machines, times) in enumerate(operations):
            operations_list.append({
                'job_id': job_id,
                'op_idx': op_idx + 1,  # Operation number
                'machines': machines,
                'times': times
            })

    # Sort operations based on the shortest processing time available
    operations_list.sort(key=lambda op: min(op['times']))

    for operation in operations_list:
        job_id = operation['job_id']
        op_idx = operation['op_idx']
        machines = operation['machines']
        times = operation['times']

        # Find the best machine for the operation based on earliest available time
        best_machine = None
        min_end_time = float('inf')

        for m_idx, machine in enumerate(machines):
            processing_time = times[m_idx]
            start_time = max(machine_available_times[machine], job_completion_times[job_id])
            end_time = start_time + processing_time

            if end_time < min_end_time:
                min_end_time = end_time
                best_machine = machine
                best_start_time = start_time
                best_processing_time = processing_time

        # Assign the operation to the best machine
        machine_available_times[best_machine] = best_start_time + best_processing_time
        job_completion_times[job_id] = best_start_time + best_processing_time

        # Add operation to schedule
        if job_id not in schedule:
            schedule[job_id] = []

        schedule[job_id].append({
            'Operation': op_idx,
            'Assigned Machine': best_machine,
            'Start Time': best_start_time,
            'End Time': best_start_time + best_processing_time,
            'Processing Time': best_processing_time
        })

    return schedule
