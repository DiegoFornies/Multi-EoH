
def heuristic(input_data):
    """
    A heuristic for the Flexible Job Shop Scheduling Problem (FJSP).

    This heuristic prioritizes operations based on a combination of factors:
    - Shortest processing time: Favors operations that can be completed quickly.
    - Least flexible operation: Favors operations with fewer machine options.
    - Earliest start time:  Prioritizes operations that can start sooner, considering machine availability and job dependencies.

    The heuristic iterates through jobs and operations, selecting the best machine for each operation based on
    these priorities and ensuring that constraints such as machine capacity and operation sequence are respected.

    Args:
        input_data (dict): A dictionary describing the FJSP instance.

    Returns:
        dict: A solution represented as a dictionary, where each key is a job number
              and the value is a list of dictionaries containing the schedule for each
              operation within that job.
    """
    n_jobs = input_data['n_jobs']
    n_machines = input_data['n_machines']
    jobs = input_data['jobs']

    # Initialize data structures
    machine_available_times = {m: 0 for m in range(n_machines)}  # When each machine becomes available
    job_completion_times = {j: 0 for j in range(1, n_jobs + 1)}  # When each job's previous operation completes
    schedule = {j: [] for j in range(1, n_jobs + 1)}  # The final schedule

    # Create a list of operations that are ready to be scheduled
    ready_operations = []
    for job_id, operations in jobs.items():
        if operations:
            ready_operations.append((job_id, 0))  # (job_id, operation_index)

    # Main scheduling loop
    while ready_operations:
        # Select the best operation based on the heuristic criteria
        best_operation = None
        best_priority = float('inf')  # Lower is better

        for job_id, operation_index in ready_operations:
            machines, times = jobs[job_id][operation_index]

            # Calculate the priority for this operation
            # Heuristic: shortest processing time, least flexibility, earliest start
            priority = sum(times) / len(times) + len(machines) * 0.1  # Average processing time + machine options

            if priority < best_priority:
                best_priority = priority
                best_operation = (job_id, operation_index)

        # If no operation could be selected (shouldn't happen, but handle for safety)
        if best_operation is None:
            break  # Exit the loop (handle error)

        job_id, operation_index = best_operation
        machines, times = jobs[job_id][operation_index]

        # Select the best machine for the operation
        best_machine = None
        earliest_start_time = float('inf')

        for m_index, machine in enumerate(machines):
            start_time = max(machine_available_times[machine], job_completion_times[job_id])
            if start_time < earliest_start_time:
                earliest_start_time = start_time
                best_machine = machine
                processing_time = times[m_index]

        # Schedule the operation on the selected machine
        start_time = earliest_start_time
        end_time = start_time + processing_time

        schedule[job_id].append({
            'Operation': operation_index + 1,
            'Assigned Machine': best_machine,
            'Start Time': start_time,
            'End Time': end_time,
            'Processing Time': processing_time
        })

        # Update machine availability and job completion time
        machine_available_times[best_machine] = end_time
        job_completion_times[job_id] = end_time

        # Remove the scheduled operation from the ready list
        ready_operations.remove((job_id, operation_index))

        # Add the next operation for the job to the ready list, if it exists
        if operation_index + 1 < len(jobs[job_id]):
            ready_operations.append((job_id, operation_index + 1))

    return schedule
