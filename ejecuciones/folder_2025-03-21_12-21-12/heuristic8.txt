
def heuristic(input_data):
    """
    A heuristic for the Flexible Job Shop Scheduling Problem (FJSSP).

    This heuristic aims to minimize makespan, reduce the time between operations in the same job,
    and balance machine load. It considers multiple machines and processing times for each operation
    and respects the constraints of operation feasibility, machine feasibility, and sequence feasibility.

    Args:
        input_data (dict): A dictionary containing the problem data, including the number of jobs,
                           number of machines, and a description of each job's operations.

    Returns:
        dict: A dictionary representing the schedule, where each key is a job number and the value
              is a list of dictionaries, each describing an operation with its assigned machine,
              start time, end time, and processing time.
    """

    n_jobs = input_data['n_jobs']
    n_machines = input_data['n_machines']
    jobs = input_data['jobs']

    # Initialize data structures
    schedule = {}
    machine_available_time = {m: 0 for m in range(n_machines)}
    job_completion_time = {j: 0 for j in jobs}

    # Prioritize jobs based on total processing time (Longest Processing Time first)
    job_priorities = {}
    for job, operations in jobs.items():
        total_processing_time = 0
        for machines, times in operations:
            total_processing_time += min(times)  # Approximate by considering minimum possible time
        job_priorities[job] = total_processing_time

    sorted_jobs = sorted(job_priorities.items(), key=lambda item: item[1], reverse=True)

    # Iterate through jobs based on priority
    for job, _ in sorted_jobs:
        schedule[job] = []
        operations = jobs[job]
        current_job_completion_time = job_completion_time[job]

        # Iterate through operations for each job
        for op_index, (machines, times) in enumerate(operations):
            best_machine = None
            best_start_time = float('inf')
            best_processing_time = None

            # Find the best machine for the current operation
            for machine_index, machine in enumerate(machines):
                processing_time = times[machine_index]
                start_time = max(machine_available_time[machine], current_job_completion_time)

                if start_time < best_start_time:
                    best_start_time = start_time
                    best_machine = machine
                    best_processing_time = processing_time

            # Schedule the operation on the best machine
            if best_machine is not None:
                start_time = best_start_time
                end_time = start_time + best_processing_time

                schedule[job].append({
                    'Operation': op_index + 1,
                    'Assigned Machine': best_machine,
                    'Start Time': start_time,
                    'End Time': end_time,
                    'Processing Time': best_processing_time
                })

                # Update machine availability and job completion time
                machine_available_time[best_machine] = end_time
                current_job_completion_time = end_time
                job_completion_time[job] = end_time

    return schedule
