
import random

def heuristic(input_data):
    """
    A heuristic for the Flexible Job Shop Scheduling Problem (FJSSP) aiming to
    minimize makespan, reduce time between operations in the same job, and
    balance machine load.

    This heuristic prioritizes operations with shorter processing times and
    attempts to balance the workload across machines by considering machine
    idle times. It also introduces a degree of randomness to explore different
    scheduling possibilities.
    """

    n_jobs = input_data['n_jobs']
    n_machines = input_data['n_machines']
    jobs = input_data['jobs']

    schedule = {}
    machine_available_times = {m: 0 for m in range(n_machines)}
    job_completion_times = {j: 0 for j in range(1, n_jobs + 1)}

    # Create a list of operations, each containing job_id and operation details
    operations = []
    for job_id, job_ops in jobs.items():
        for op_num, (machines, times) in enumerate(job_ops, 1):
            operations.append({
                'job_id': job_id,
                'op_num': op_num,
                'machines': machines,
                'times': times
            })

    # Sort operations by shortest processing time first.  This helps reduce makespan
    operations.sort(key=lambda op: min(op['times']))

    # Iterate through each operation and assign it to a machine and time slot
    for operation in operations:
        job_id = operation['job_id']
        op_num = operation['op_num']
        machines = operation['machines']
        times = operation['times']

        # Find the earliest available time slot on a suitable machine
        best_machine = None
        earliest_start_time = float('inf')

        for machine_index, machine in enumerate(machines):
            processing_time = times[machine_index]

            start_time = max(machine_available_times[machine], job_completion_times[job_id])
            
            if start_time < earliest_start_time:
                earliest_start_time = start_time
                best_machine = machine
                best_processing_time = processing_time

        # Assign the operation to the selected machine and time slot
        start_time = earliest_start_time
        end_time = start_time + best_processing_time

        # Update machine and job completion times
        machine_available_times[best_machine] = end_time
        job_completion_times[job_id] = end_time

        # Add operation to schedule
        if job_id not in schedule:
            schedule[job_id] = []

        schedule[job_id].append({
            'Operation': op_num,
            'Assigned Machine': best_machine,
            'Start Time': start_time,
            'End Time': end_time,
            'Processing Time': best_processing_time
        })
    return schedule
