
def heuristic(data):
    """
    A heuristic algorithm for the Flexible Job Shop Scheduling Problem (FJSSP).
    This function prioritizes a balance between makespan, separation, and machine balance,
    addressing the limitations of solely minimizing makespan early in the scheduling process.
    It employs a dynamic weighting approach to achieve well-rounded solutions.

    Args:
        data (dict): A dictionary containing the problem instance data, including:
            - n_jobs (int): The number of jobs.
            - n_machines (int): The number of machines.
            - jobs (dict): A dictionary representing the jobs, where each key is a job number
              and the value is a list of operations. Each operation is a tuple containing a list
              of candidate machines and a list of corresponding processing times.

    Returns:
        dict: A dictionary representing the generated schedule. The keys are job numbers, and the
              values are lists of dictionaries, each representing an operation with its assigned
              machine, start time, end time, and processing time.
    """

    n_jobs = data['n_jobs']
    n_machines = data['n_machines']
    jobs_data = data['jobs']

    schedule = {}
    machine_available_times = {m: 0 for m in range(1, n_machines + 1)}
    job_last_end_times = {j: 0 for j in range(1, n_jobs + 1)}

    for job_id in range(1, n_jobs + 1):
        schedule[job_id] = []
        job = jobs_data[job_id]
        for operation_index, operation in enumerate(job):
            machines = operation[0]
            times = operation[1]

            # Dynamic Weighting:  Balance makespan and separation.
            # Favor machines that are available sooner AND lead to smaller time differences
            # between consecutive operations in the same job.

            best_machine = None
            min_weighted_time = float('inf')

            for machine_index, machine in enumerate(machines):
                processing_time = times[machine_index]
                available_time = machine_available_times[machine]
                job_ready_time = job_last_end_times[job_id]

                # Calculate separation cost (time between operations within the same job)
                separation_cost = max(0, available_time - job_ready_time)  # Encourage smaller gaps

                # A simple weighting scheme - could be tuned based on performance
                weighted_time = available_time + separation_cost + processing_time * 0.5  # Balance all times


                if weighted_time < min_weighted_time:
                    min_weighted_time = weighted_time
                    best_machine = machine
                    best_processing_time = processing_time


            start_time = max(machine_available_times[best_machine], job_last_end_times[job_id])
            end_time = start_time + best_processing_time

            schedule[job_id].append({
                'Operation': operation_index + 1,
                'Assigned Machine': str(best_machine),
                'Start Time': start_time,
                'End Time': end_time,
                'Processing Time': best_processing_time
            })

            machine_available_times[best_machine] = end_time
            job_last_end_times[job_id] = end_time

    return schedule
